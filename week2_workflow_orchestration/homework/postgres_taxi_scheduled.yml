id: postgres_taxi_schedule
namespace: zoomcamp
description: Best to add a label `backfill:true` in the UI to track executions created via a backfill

concurrency:
  limit: 1

inputs:
  - id: taxi
    type: SELECT
    displayName: 'Select taxi type'
    values: ['yellow', 'green']
    defaults: 'yellow'

variables:
  # File to download
  file: '{{ inputs.taxi }}_tripdata_{{ trigger.date | date(''yyyy-MM'') }}.csv'
  # Monthly data table
  staging_table: 'public.{{ inputs.taxi }}_tripdata_staging'
  # Full data table
  table: 'public.{{ inputs.taxi }}_tripdata'
  # The data itself, generated based on the output from the extract task
  data: '{{ outputs.extract.outputFiles[inputs.taxi ~ ''_tripdata_'' ~ (trigger.date | date(''yyyy-MM'')) ~ ''.csv'' ]}}'

tasks:
  - id: set_label
    type: io.kestra.plugin.core.execution.Labels
    labels:
      file: '{{ render(vars.file) }}'
      taxi: '{{ inputs.taxi }}'
  
  - id: extract
    type: io.kestra.plugin.scripts.shell.Commands
    outputFiles:
      - '*.csv'
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
        # Download in "quiet mode" (-q) and specify the output (-O)
        # Use gunzip to decompress .gz files
        - wget -qO- https://github.com/DataTalksClub/nyc-tlc-data/releases/download/{{ inputs.taxi }}/{{ render(vars.file) }}.gz | gunzip > {{ render(vars.file) }}

  - id: if_green
    type: io.kestra.plugin.core.flow.If
    condition: '{{ inputs.taxi == ''green'' }}'
    then:
      - id: green_create_table
        type: io.kestra.plugin.jdbc.postgresql.Queries
        # In the SQL, create a unique row ID generated via a 
        #   MD5 hash and note which file the row came from
        sql:
          CREATE TABLE IF NOT EXISTS {{ render(vars.table) }} (
            unique_row_id          text,
            filename               text,
            VendorID               text,
            lpep_pickup_datetime   timestamp,
            lpep_dropoff_datetime  timestamp,
            store_and_fwd_flag     text,
            RatecodeID             text,
            PULocationID           text,
            DOLocationID           text,
            passenger_count        integer,
            trip_distance          double precision,
            fare_amount            double precision,
            extra                  double precision,
            mta_tax                double precision,
            tip_amount             double precision,
            tolls_amount           double precision,
            ehail_fee              double precision,
            improvement_surcharge  double precision,
            total_amount           double precision,
            payment_type           integer,
            trip_type              integer,
            congestion_surcharge   double precision
            )
          ;

      - id: green_create_staging_table
        type: io.kestra.plugin.jdbc.postgresql.Queries
        # In the SQL, create a unique row ID generated via a 
        #   MD5 hash and note which file the row came from
        sql:
          CREATE TABLE IF NOT EXISTS {{ render(vars.staging_table) }} (
            unique_row_id          text,
            filename               text,
            VendorID               text,
            lpep_pickup_datetime   timestamp,
            lpep_dropoff_datetime  timestamp,
            store_and_fwd_flag     text,
            RatecodeID             text,
            PULocationID           text,
            DOLocationID           text,
            passenger_count        integer,
            trip_distance          double precision,
            fare_amount            double precision,
            extra                  double precision,
            mta_tax                double precision,
            tip_amount             double precision,
            tolls_amount           double precision,
            ehail_fee              double precision,
            improvement_surcharge  double precision,
            total_amount           double precision,
            payment_type           integer,
            trip_type              integer,
            congestion_surcharge   double precision
            )
          ;

      - id: green_truncate_staging_table
        type: io.kestra.plugin.jdbc.postgresql.Queries
        sql:
          TRUNCATE TABLE {{ render(vars.staging_table )}};

      - id: green_copy_into_staging_table
        type: io.kestra.plugin.jdbc.postgresql.CopyIn
        format: CSV
        from: '{{ render(vars.data) }}'
        table: '{{ render(vars.staging_table) }}'
        header: true
        columns: [VendorID, lpep_pickup_datetime, lpep_dropoff_datetime, store_and_fwd_flag,
          RatecodeID, PULocationID, DOLocationID, passenger_count, trip_distance, fare_amount,
          extra, mta_tax, tip_amount, tolls_amount, ehail_fee, improvement_surcharge,
          total_amount, payment_type, trip_type, congestion_surcharge]

      - id: green_add_unique_id_and_filename
        type: io.kestra.plugin.jdbc.postgresql.Queries
        sql:
          UPDATE {{ render(vars.staging_table )}}
          SET
            unique_row_id = md5(
              COALESCE(CAST(VendorID AS text), '') ||
              COALESCE(CAST(lpep_pickup_datetime AS text), '') ||
              COALESCE(CAST(lpep_dropoff_datetime AS text), '') ||
              COALESCE(PULocationID, '') ||
              COALESCE(DOLocationID, '') ||
              COALESCE(CAST(fare_amount AS text), '') ||
              COALESCE(CAST(trip_distance AS text), '')
            ),
            filename = '{{ render(vars.file )}}'
          ;

      - id: green_merge_data
        type: io.kestra.plugin.jdbc.postgresql.Queries
        sql:
          MERGE INTO {{ render(vars.table) }} AS final
          USING {{ render(vars.staging_table) }} AS staging
          ON final.unique_row_id = staging.unique_row_id
          
          WHEN NOT MATCHED THEN
            INSERT (
              unique_row_id, filename, VendorID, lpep_pickup_datetime, lpep_dropoff_datetime,
              store_and_fwd_flag, RatecodeID, PULocationID, DOLocationID, passenger_count,
              trip_distance, fare_amount, extra, mta_tax, tip_amount, tolls_amount, ehail_fee,
              improvement_surcharge, total_amount, payment_type, trip_type, congestion_surcharge
            )
            VALUES (
              staging.unique_row_id, staging.filename, staging.VendorID,
              staging.lpep_pickup_datetime, staging.lpep_dropoff_datetime,
              staging.store_and_fwd_flag, staging.RatecodeID, staging.PULocationID,
              staging.DOLocationID, staging.passenger_count, staging.trip_distance,
              staging.fare_amount, staging.extra, staging.mta_tax, staging.tip_amount,
              staging.tolls_amount, staging.ehail_fee, staging.improvement_surcharge,
              staging.total_amount, staging.payment_type, staging.trip_type,
              staging.congestion_surcharge
            )
          ;

  - id: if_yellow
    type: io.kestra.plugin.core.flow.If
    condition: '{{ inputs.taxi == ''yellow'' }}'
    then:
      - id: yellow_create_table
        type: io.kestra.plugin.jdbc.postgresql.Queries
        # In the SQL, create a unique row ID generated via a 
        #   MD5 hash and note which file the row came from
        sql:
          CREATE TABLE IF NOT EXISTS {{ render(vars.table) }} (
            unique_row_id          text,
            filename               text,
            VendorID               text,
            tpep_pickup_datetime   timestamp,
            tpep_dropoff_datetime  timestamp,
            passenger_count        integer,
            trip_distance          double precision,
            RatecodeID             text,
            store_and_fwd_flag     text,
            PULocationID           text,
            DOLocationID           text,
            payment_type           integer,
            fare_amount            double precision,
            extra                  double precision,
            mta_tax                double precision,
            tip_amount             double precision,
            tolls_amount           double precision,
            improvement_surcharge  double precision,
            total_amount           double precision,
            congestion_surcharge   double precision
            )
          ;

      - id: yellow_create_staging_table
        type: io.kestra.plugin.jdbc.postgresql.Queries
        # In the SQL, create a unique row ID generated via a 
        #   MD5 hash and note which file the row came from
        sql:
          CREATE TABLE IF NOT EXISTS {{ render(vars.staging_table) }} (
            unique_row_id          text,
            filename               text,
            VendorID               text,
            tpep_pickup_datetime   timestamp,
            tpep_dropoff_datetime  timestamp,
            passenger_count        integer,
            trip_distance          double precision,
            RatecodeID             text,
            store_and_fwd_flag     text,
            PULocationID           text,
            DOLocationID           text,
            payment_type           integer,
            fare_amount            double precision,
            extra                  double precision,
            mta_tax                double precision,
            tip_amount             double precision,
            tolls_amount           double precision,
            improvement_surcharge  double precision,
            total_amount           double precision,
            congestion_surcharge   double precision
            )
          ;

      - id: yellow_truncate_staging_table
        type: io.kestra.plugin.jdbc.postgresql.Queries
        sql:
          TRUNCATE TABLE {{ render(vars.staging_table )}};

      - id: yellow_copy_into_staging_table
        type: io.kestra.plugin.jdbc.postgresql.CopyIn
        format: CSV
        from: '{{ render(vars.data) }}'
        table: '{{ render(vars.staging_table) }}'
        header: true
        columns: [VendorID, tpep_pickup_datetime, tpep_dropoff_datetime, passenger_count,
          trip_distance, RatecodeID, store_and_fwd_flag, PULocationID, DOLocationID,
          payment_type, fare_amount, extra, mta_tax, tip_amount, tolls_amount,
          improvement_surcharge, total_amount, congestion_surcharge]

      - id: yellow_add_unique_id_and_filename
        type: io.kestra.plugin.jdbc.postgresql.Queries
        sql:
          UPDATE {{ render(vars.staging_table )}}
          SET
            unique_row_id = md5(
              COALESCE(CAST(VendorID AS text), '') ||
              COALESCE(CAST(tpep_pickup_datetime AS text), '') ||
              COALESCE(CAST(tpep_dropoff_datetime AS text), '') ||
              COALESCE(PULocationID, '') ||
              COALESCE(DOLocationID, '') ||
              COALESCE(CAST(fare_amount AS text), '') ||
              COALESCE(CAST(trip_distance AS text), '')
            ),
            filename = '{{ render(vars.file )}}'
          ;

      - id: yellow_merge_data
        type: io.kestra.plugin.jdbc.postgresql.Queries
        sql:
          MERGE INTO {{ render(vars.table) }} AS final
          USING {{ render(vars.staging_table) }} AS staging
          ON final.unique_row_id = staging.unique_row_id
          
          WHEN NOT MATCHED THEN
            INSERT (
              unique_row_id, filename, VendorID, tpep_pickup_datetime, tpep_dropoff_datetime, passenger_count, trip_distance, RatecodeID, store_and_fwd_flag, PULocationID,
              DOLocationID, payment_type, fare_amount, extra, mta_tax, tip_amount, tolls_amount,
              improvement_surcharge, total_amount, congestion_surcharge
            )
            VALUES (
              staging.unique_row_id, staging.filename, staging.VendorID,
              staging.tpep_pickup_datetime, staging.tpep_dropoff_datetime,
              staging.passenger_count, staging.trip_distance, staging.RatecodeID,
              staging.store_and_fwd_flag, staging.PULocationID, staging.DOLocationID,
              staging.payment_type, staging.fare_amount, staging.extra, staging.mta_tax,
              staging.tip_amount, staging.tolls_amount, staging.improvement_surcharge,
              staging.total_amount, staging.congestion_surcharge
            )
          ;

  - id: purge_files
    type: io.kestra.plugin.core.storage.PurgeCurrentExecutionFiles
    description: This will remove output files. If you'd like to explore Kestra outputs, disable this task.
    # disable: true
    

pluginDefaults:
  - type: io.kestra.plugin.jdbc.postgresql
    values:
      url: jdbc:postgresql://host.docker.internal:5432/postgres-zoomcamp
      username: kestra
      password: k3str4

triggers:
  - id: green_schedule
    type: io.kestra.plugin.core.trigger.Schedule
    cron: '0 9 1 * *'
    inputs:
      taxi: green

  - id: yellow_schedule
    type: io.kestra.plugin.core.trigger.Schedule
    cron: '0 10 1 * *'
    inputs:
      taxi: yellow
